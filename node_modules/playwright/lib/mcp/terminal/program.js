"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var program_exports = {};
__export(program_exports, {
  program: () => program
});
module.exports = __toCommonJS(program_exports);
var import_child_process = require("child_process");
var import_crypto = __toESM(require("crypto"));
var import_fs = __toESM(require("fs"));
var import_net = __toESM(require("net"));
var import_os = __toESM(require("os"));
var import_path = __toESM(require("path"));
var import_socketConnection = require("./socketConnection");
class Session {
  constructor(clientVersion, name, options) {
    this._nextMessageId = 1;
    this._callbacks = /* @__PURE__ */ new Map();
    this.name = name;
    this._clientVersion = clientVersion;
    this._config = options;
  }
  config() {
    return this._config;
  }
  isCompatible() {
    return this._clientVersion === this._config.version;
  }
  checkCompatible() {
    if (!this.isCompatible()) {
      throw new Error(`Client is v${this._clientVersion}, session '${this.name}' is v${this._config.version}. Run

  playwright-cli session-restart${this.name !== "default" ? ` ${this.name}` : ""}

to restart the session daemon.`);
    }
  }
  async run(args) {
    this.checkCompatible();
    return await this._send("run", { args, cwd: process.cwd() });
  }
  async stop() {
    if (!await this.canConnect()) {
      console.log(`Session '${this.name}' is not running.`);
      return;
    }
    await this._send("stop").catch((e) => {
      if (e.message !== "Session closed")
        throw e;
    });
    this.close();
    if (import_os.default.platform() !== "win32")
      await import_fs.default.promises.unlink(this._config.socketPath).catch(() => {
      });
    console.log(`Session '${this.name}' stopped.`);
  }
  async restart(config) {
    await this.stop();
    this._config = config;
    await this._startDaemonIfNeeded();
  }
  async _send(method, params = {}) {
    const connection = await this._startDaemonIfNeeded();
    const messageId = this._nextMessageId++;
    const message = {
      id: messageId,
      method,
      params,
      version: this._config.version
    };
    const responsePromise = new Promise((resolve, reject) => {
      this._callbacks.set(messageId, { resolve, reject, method, params });
    });
    const [result] = await Promise.all([responsePromise, connection.send(message)]);
    return result;
  }
  close() {
    if (!this._connection)
      return;
    for (const callback of this._callbacks.values())
      callback.reject(new Error("Session closed"));
    this._callbacks.clear();
    this._connection.close();
    this._connection = void 0;
  }
  async delete() {
    await this.stop();
    const dataDirs = await import_fs.default.promises.readdir(daemonProfilesDir).catch(() => []);
    const matchingEntries = dataDirs.filter((file) => file === `${this.name}.session` || file.startsWith(`ud-${this.name}-`));
    if (matchingEntries.length === 0) {
      console.log(`No user data found for session '${this.name}'.`);
      return;
    }
    for (const entry of matchingEntries) {
      const userDataDir = import_path.default.resolve(daemonProfilesDir, entry);
      for (let i = 0; i < 5; i++) {
        try {
          await import_fs.default.promises.rm(userDataDir, { recursive: true });
          if (entry.startsWith("ud-"))
            console.log(`Deleted user data for session '${this.name}'.`);
          break;
        } catch (e) {
          if (e.code === "ENOENT") {
            console.log(`No user data found for session '${this.name}'.`);
            break;
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          if (i === 4)
            throw e;
        }
      }
    }
  }
  async _connect() {
    return await new Promise((resolve) => {
      const socket = import_net.default.createConnection(this._config.socketPath, () => {
        resolve({ socket });
      });
      socket.on("error", (error) => {
        if (import_os.default.platform() !== "win32")
          void import_fs.default.promises.unlink(this._config.socketPath).catch(() => {
          }).then(() => resolve({ error }));
        else
          resolve({ error });
      });
    });
  }
  async canConnect() {
    const { socket } = await this._connect();
    if (socket) {
      socket.destroy();
      return true;
    }
    return false;
  }
  async _startDaemonIfNeeded() {
    if (this._connection)
      return this._connection;
    let { socket } = await this._connect();
    if (!socket)
      socket = await this._startDaemon();
    this._connection = new import_socketConnection.SocketConnection(socket, this._config.version);
    this._connection.onmessage = (message) => this._onMessage(message);
    this._connection.onclose = () => this.close();
    return this._connection;
  }
  _onMessage(object) {
    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.error)
        callback.reject(new Error(object.error));
      else
        callback.resolve(object.result);
    } else if (object.id) {
      throw new Error(`Unexpected message id: ${object.id}`);
    } else {
      throw new Error(`Unexpected message without id: ${JSON.stringify(object)}`);
    }
  }
  async _startDaemon() {
    await import_fs.default.promises.mkdir(daemonProfilesDir, { recursive: true });
    const cliPath = import_path.default.join(__dirname, "../../../cli.js");
    const sessionConfigFile = import_path.default.resolve(daemonProfilesDir, `${this.name}.session`);
    this._config.version = this._clientVersion;
    await import_fs.default.promises.writeFile(sessionConfigFile, JSON.stringify(this._config, null, 2));
    const outLog = import_path.default.join(daemonProfilesDir, "out.log");
    const errLog = import_path.default.join(daemonProfilesDir, "err.log");
    const out = import_fs.default.openSync(outLog, "w");
    const err = import_fs.default.openSync(errLog, "w");
    const args = [
      cliPath,
      "run-mcp-server",
      `--output-dir=${outputDir}`,
      `--daemon-session=${sessionConfigFile}`
    ];
    const child = (0, import_child_process.spawn)(process.execPath, args, {
      detached: true,
      stdio: ["ignore", out, err],
      cwd: process.cwd()
      // Will be used as root.
    });
    child.unref();
    console.log(`<!-- Daemon for \`${this.name}\` session started with pid ${child.pid}.`);
    if (this._config.cli.config)
      console.log(`- Using config file at \`${import_path.default.relative(process.cwd(), this._config.cli.config)}\`.`);
    const sessionSuffix = this.name !== "default" ? ` "${this.name}"` : "";
    console.log(`- You can stop the session daemon with \`playwright-cli session-stop${sessionSuffix}\` when done.`);
    console.log(`- You can delete the session data with \`playwright-cli session-delete${sessionSuffix}\` when done.`);
    console.log("-->");
    const maxRetries = 50;
    const retryDelay = 100;
    for (let i = 0; i < maxRetries; i++) {
      await new Promise((resolve) => setTimeout(resolve, retryDelay));
      try {
        const { socket } = await this._connect();
        if (socket)
          return socket;
      } catch (e) {
        if (e.code !== "ENOENT" && e.code !== "ECONNREFUSED")
          throw e;
      }
    }
    const outData = await import_fs.default.promises.readFile(outLog, "utf-8").catch(() => "");
    const errData = await import_fs.default.promises.readFile(errLog, "utf-8").catch(() => "");
    console.error(`Failed to connect to daemon at ${this._config.socketPath} after ${maxRetries * retryDelay}ms`);
    if (outData.length)
      console.log(outData);
    if (errData.length)
      console.error(errData);
    process.exit(1);
  }
}
class SessionManager {
  constructor(clientVersion, sessions, args) {
    this.clientVersion = clientVersion;
    this.sessions = sessions;
  }
  static async create(clientVersion, args) {
    const dir = daemonProfilesDir;
    const sessions = /* @__PURE__ */ new Map();
    const files = await import_fs.default.promises.readdir(dir).catch(() => []);
    for (const file of files) {
      try {
        if (file.endsWith(".session")) {
          const sessionName = import_path.default.basename(file, ".session");
          const sessionConfig = await import_fs.default.promises.readFile(import_path.default.join(dir, file), "utf-8").then((data) => JSON.parse(data));
          sessions.set(sessionName, new Session(clientVersion, sessionName, sessionConfig));
          continue;
        }
        if (file.startsWith("ud-")) {
          const sessionName = file.split("-")[1];
          if (!sessions.has(sessionName)) {
            const sessionConfig = sessionConfigFromArgs("0.0.61", sessionName, { _: [] });
            sessions.set(sessionName, new Session(clientVersion, sessionName, sessionConfig));
          }
        }
      } catch {
      }
    }
    return new SessionManager(clientVersion, sessions, args);
  }
  async run(args) {
    const sessionName = this._resolveSessionName(args.session);
    let session = this.sessions.get(sessionName);
    if (!session) {
      session = new Session(this.clientVersion, sessionName, sessionConfigFromArgs(this.clientVersion, sessionName, args));
      this.sessions.set(sessionName, session);
    }
    for (const globalOption of ["browser", "config", "extension", "headed", "help", "isolated", "session", "version"])
      delete args[globalOption];
    const result = await session.run(args);
    console.log(result.text);
    session.close();
  }
  async stop(sessionName) {
    sessionName = this._resolveSessionName(sessionName);
    const session = this.sessions.get(sessionName);
    if (!session || !await session.canConnect()) {
      console.log(`Session '${sessionName}' is not running.`);
      return;
    }
    await session.stop();
  }
  async delete(sessionName) {
    sessionName = this._resolveSessionName(sessionName);
    const session = this.sessions.get(sessionName);
    if (!session) {
      console.log(`No user data found for session '${sessionName}'.`);
      return;
    }
    await session.delete();
    this.sessions.delete(sessionName);
  }
  async restart(sessionName) {
    sessionName = this._resolveSessionName(sessionName);
    const session = this.sessions.get(sessionName);
    if (!session) {
      console.log(`Session '${sessionName}' does not exist.`);
      return;
    }
    await session.restart(session.config());
    session.close();
  }
  async configure(args) {
    const sessionName = this._resolveSessionName(args.session);
    let session = this.sessions.get(sessionName);
    const sessionConfig = sessionConfigFromArgs(this.clientVersion, sessionName, args);
    if (!session) {
      session = new Session(this.clientVersion, sessionName, sessionConfig);
      this.sessions.set(sessionName, session);
    }
    await session.restart(sessionConfig);
    session.close();
  }
  _resolveSessionName(sessionName) {
    if (sessionName)
      return sessionName;
    if (process.env.PLAYWRIGHT_CLI_SESSION)
      return process.env.PLAYWRIGHT_CLI_SESSION;
    return "default";
  }
}
async function handleSessionCommand(sessionManager, subcommand, args) {
  if (subcommand === "list") {
    const sessions = sessionManager.sessions;
    console.log("Sessions:");
    for (const session of sessions.values()) {
      const liveMarker = await session.canConnect() ? `[running] ` : "[stopped] ";
      const restartMarker = !session.isCompatible() ? ` - v${session.config().version}, needs restart` : "";
      console.log(`  ${liveMarker}${session.name}${restartMarker}`);
    }
    if (sessions.size === 0)
      console.log("  (no sessions)");
    return;
  }
  if (subcommand === "restart") {
    await sessionManager.restart(args._[1]);
    return;
  }
  if (subcommand === "stop") {
    await sessionManager.stop(args._[1]);
    return;
  }
  if (subcommand === "stop-all") {
    const sessions = sessionManager.sessions;
    for (const session of sessions.values())
      await session.stop();
    return;
  }
  if (subcommand === "delete") {
    await sessionManager.delete(args._[1]);
    return;
  }
  if (subcommand === "config") {
    await sessionManager.configure(args);
    return;
  }
  console.error(`Unknown session subcommand: ${subcommand}`);
  process.exit(1);
}
const installationDirHash = (() => {
  const hash = import_crypto.default.createHash("sha1");
  hash.update(process.env.PLAYWRIGHT_DAEMON_INSTALL_DIR || require.resolve("../../../package.json"));
  return hash.digest("hex").substring(0, 16);
})();
const daemonProfilesDir = (() => {
  if (process.env.PLAYWRIGHT_DAEMON_SESSION_DIR)
    return process.env.PLAYWRIGHT_DAEMON_SESSION_DIR;
  let localCacheDir;
  if (process.platform === "linux")
    localCacheDir = process.env.XDG_CACHE_HOME || import_path.default.join(import_os.default.homedir(), ".cache");
  if (process.platform === "darwin")
    localCacheDir = import_path.default.join(import_os.default.homedir(), "Library", "Caches");
  if (process.platform === "win32")
    localCacheDir = process.env.LOCALAPPDATA || import_path.default.join(import_os.default.homedir(), "AppData", "Local");
  if (!localCacheDir)
    throw new Error("Unsupported platform: " + process.platform);
  return import_path.default.join(localCacheDir, "ms-playwright", "daemon", installationDirHash);
})();
const booleanOptions = [
  "extension",
  "headed",
  "help",
  "isolated",
  "version"
];
async function program(options) {
  const version = process.env.PLAYWRIGHT_CLI_VERSION_FOR_TEST || options.version;
  const argv = process.argv.slice(2);
  const args = require("minimist")(argv, { boolean: booleanOptions });
  for (const option of booleanOptions) {
    if (!argv.includes(`--${option}`) && !argv.includes(`--no-${option}`))
      delete args[option];
  }
  const help = require("./help.json");
  const commandName = args._[0];
  if (args.version || args.v) {
    console.log(version);
    process.exit(0);
  }
  const command = help.commands[commandName];
  if (args.help || args.h) {
    if (command) {
      console.log(command);
    } else {
      console.log("playwright-cli - run playwright mcp commands from terminal\n");
      console.log(help.global);
    }
    process.exit(0);
  }
  if (!command) {
    console.error(`Unknown command: ${commandName}
`);
    console.log(help.global);
    process.exit(1);
  }
  const sessionManager = await SessionManager.create(version, args);
  if (commandName.startsWith("session")) {
    const subcommand = args._[0].split("-").slice(1).join("-");
    await handleSessionCommand(sessionManager, subcommand, args);
    return;
  }
  if (commandName === "config") {
    await handleSessionCommand(sessionManager, "config", args);
    return;
  }
  if (commandName === "close") {
    await handleSessionCommand(sessionManager, "stop", args);
    return;
  }
  await sessionManager.run(args);
}
const outputDir = import_path.default.join(process.cwd(), ".playwright-cli");
function daemonSocketPath(sessionName) {
  const socketName = `${sessionName}.sock`;
  if (import_os.default.platform() === "win32")
    return `\\\\.\\pipe\\${installationDirHash}-${socketName}`;
  const socketsDir = process.env.PLAYWRIGHT_DAEMON_SOCKETS_DIR || import_path.default.join(import_os.default.tmpdir(), "playwright-cli");
  return import_path.default.join(socketsDir, installationDirHash, socketName);
}
function sessionConfigFromArgs(version, sessionName, args) {
  let config = args.config;
  try {
    if (!config && import_fs.default.existsSync("playwright-cli.json"))
      config = import_path.default.resolve("playwright-cli.json");
  } catch {
  }
  return {
    version,
    socketPath: daemonSocketPath(sessionName),
    cli: {
      headed: args.headed,
      extension: args.extension,
      browser: args.browser,
      isolated: args.isolated,
      config
    },
    userDataDirPrefix: import_path.default.resolve(daemonProfilesDir, `ud-${sessionName}`)
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  program
});
